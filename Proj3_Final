
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Scrollable File Contents Viewer class
class FileContentsViewer(swing.JFrame):
   import os
   import java
   
   # ----------------
   # Class vars
   currentDirectory = ""
   files = None
   # ----------------
   
   
   # DESC: Initialization of the frame. Creates the buttons and file list
   #
   # INPUTS:   directory, String of directory on computer
   # OUTPUTS:  JFrame
   def __init__(self, directory=""):
      swing.JFrame.__init__(self, title="File Contents Viewer", size=(800,600))
      self.setLocationByPlatform(true)
      self.contentPane.layout = java.awt.BorderLayout()
      
      self.currentDirectory = directory
      filesList = self.listFilesInDirectory(self.currentDirectory)
      self.files = swing.JList(filesList)
      pane = swing.JScrollPane(self.files, name="ScrollPane", size=(400,200))
      self.contentPane.add(pane, java.awt.BorderLayout.CENTER)
      
      fileView = swing.JButton("View Contents", name="FileView", actionPerformed = self.fileView)
      self.contentPane.add(fileView, java.awt.BorderLayout.WEST)
      
      changeDir = swing.JButton("Change Directory", name="ChangeDir", actionPerformed = self.changeDirectory)
      self.contentPane.add(changeDir, java.awt.BorderLayout.SOUTH)
      
      dirHeader = swing.JLabel(self.currentDirectory, swing.JLabel.CENTER, name="Header")
      self.contentPane.add(dirHeader, java.awt.BorderLayout.NORTH)
      
      smallFrame = swing.JPanel(java.awt.GridLayout(0,1), name="ButtonGrid")
      smallFrame.add(swing.JButton("Aaron's First Project", actionPerformed=self.Aaron_First_Project))
      smallFrame.add(swing.JButton("Aaron's Second Project", actionPerformed=self.Aaron_Second_Project))
      smallFrame.add(swing.JButton("Peter's First Project", actionPerformed=self.Peter_First_Project))
      smallFrame.add(swing.JButton("Peter's Second Project", actionPerformed=self.Peter_Second_Project))
      smallFrame.add(swing.JButton("TEST", actionPerformed=self.testing))
      self.contentPane.add(smallFrame, java.awt.BorderLayout.EAST)
      
      self.pack()
      self.visible = true
   #END DEF
   
   
   # DESC: Uses the chosen file (in the frame list) and either opens it or plays it
   #
   # INPUTS:   none
   # OUTPUTS:  showing the chosen file
   def fileView(self, event):
      selected = self.files.getSelectedIndices()
      selectedFile = self.files.getModel( ).getElementAt( selected[0])
      selectedFile = self.currentDirectory+ "/"+ selectedFile
      if (selectedFile.endswith(".jpg") or selectedFile.endswith(".JPG") or
          selectedFile.endswith(".png") or selectedFile.endswith(".PNG")
          ):
         pic = makePicture(selectedFile)
         openPictureTool(pic)
      #END IF
      if selectedFile.endswith(".wav"):
         snd = makeSound(selectedFile)
         openSoundTool(snd)
         #END WHILE
      #END IF
   #END DEF
   
   
   # DESC: Change's the frame's directory, and re-declares some swing components
   #
   # INPUTS:   none
   # OUTPUTS:  none
   def changeDirectory(self, event):
      components = self.contentPane.getComponents()
      index = 0
      for elem in components:
         if elem.getName() == "ScrollPane":
            index = components.index(elem)
      self.contentPane.remove(index)
      filesList = self.listFilesInDirectory()
      self.files = swing.JList(filesList)
      pane = swing.JScrollPane(self.files, name="ScrollPane", size=(400,200))
      self.contentPane.add(pane, java.awt.BorderLayout.CENTER)
      
      components = self.contentPane.getComponents()
      index = 0
      for elem in components:
         if elem.getName() == "Header":
            index = components.index(elem)
      self.contentPane.remove(index)
      dirHeader = swing.JLabel(self.currentDirectory, swing.JLabel.CENTER, name="Header")
      self.contentPane.add(dirHeader, java.awt.BorderLayout.NORTH)
      
      self.pack()
      self.visible = true
   #END DEF
   
   # DESC: This returns a list of .jpg or .wav files in either a given or chosen directory
   #
   # INPUTS:   directory, a String that can be empty, or a directory on the computer
   # OUTPUTS:  list, an array of file names
   def listFilesInDirectory(self, directory = ""):
      if directory == "":
         chooser = swing.JFileChooser()
         chooser.setFileSelectionMode(swing.JFileChooser.DIRECTORIES_ONLY)
         chooser.setApproveButtonText("Select Folder")
         chooser.setDialogTitle("Select Folder to Show File List")
         val = None
         cancelCount = 0
         while (val != swing.JFileChooser.APPROVE_OPTION) and (cancelCount < 3):
            val = chooser.showDialog(self, None)
            if (val == swing.JFileChooser.CANCEL_OPTION):
               cancelCount += 1
         #END WHILE
         if (cancelCount == 3):
            if (self.currentDirectory == ""):
               if os.path.isdir( os.path.expanduser("~")+"/Desktop" ):
                  self.currentDirectory = os.path.expanduser("~")+"/Desktop"
               else:
                  self.currentDirectory = os.path.expanduser("~")+"/desktop"
               #END IF/ELSE
            else:
               keeping_the_current_directory = true
         else:
            self.currentDirectory = str(chooser.getSelectedFile())
         #END IF/ELSE
      else:
         self.currentDirectory = directory
      #END IF/ELSE
      tempFilesList = os.listdir(self.currentDirectory)
      toRemove = []
      for entry in tempFilesList:
         if ( (entry[0:1] == ".") or 
              (os.path.isdir(self.currentDirectory+"/"+entry)) or
              ( (entry[-4:] != ".wav") and (entry[-4:] != ".WAV") and
                (entry[-4:] != ".jpg") and (entry[-4:] != ".png") and (entry[-4:] != ".gif") and
                (entry[-4:] != ".JPG") and (entry[-4:] != ".PNG") and (entry[-4:] != ".GIF") )
            ):
            toRemove.append(entry)
         #END IF
      #END FOR
      for removing in toRemove:
         tempFilesList.remove(removing)
      #END FOR
      return tempFilesList
   #END DEF
   
   
   # DESC: Used for debugging this Object
   #
   # INPUTS:   none
   # OUTPUTS:  a JFrame window with some simple text
   def testing(self, event):
      #mywindow = swing.JFrame(size=(600,100))
      #mywindow.contentPane.add(swing.JLabel("I am here"), java.awt.BorderLayout.CENTER)
      #mywindow.visible = true
      mywindow = swing.JFrame(size=(600,100))
      mywindow.setLocationByPlatform(true)
      mywindow.contentPane.layout = java.awt.FlowLayout(java.awt.FlowLayout.LEFT)
      mywindow.contentPane.add(swing.JTextField("Hello, User."))
   #END DEF







# OUR PREVIOUS PROJECTS ARE FUNCTIONS BELOW
   
   # DESC: Uses selected audio file to create a picture. Will then create a video of the picture creating itself.
   #
   # INPUTS:   .wav file from directory list
   # OUTPUTS:  picture of audio file, video creating picture of audio file
   def Aaron_First_Project(self, event):
      #Determines directory, sets it, then creates it if it doesn't exist.
      selected = self.files.getSelectedIndices()
      selectedFile = self.files.getModel( ).getElementAt( selected[0])
      selectedFile = self.currentDirectory+ "/"+ selectedFile
      dir=self.currentDirectory+'\\pictures\\'
      if not os.path.exists(dir):
        os.makedirs(dir)
      #END IF
      #Variable declaration
      x=0
      y=0
      value=0
      data = 300
      picture=makeEmptyPicture(data,data)
      file=selectedFile
      sound=makeSound(file)
      overall=(getNumSamples(sound))/(data*data)
      int(overall)
      pixelArray=getPixels(picture)
      pixelIndex=0
      for k in range (0, data):
        for i in range (0, data):
          total=0
          for j in range (0, overall):
            total+=getSampleValueAt(sound, ((k*overall*data)+(i*overall)+j))
          avg=total/overall
          if (avg<-50):
            pixelArray[pixelIndex].setColor(red)
          #END IF
          elif(avg<-25 and avg>=-50):
            pixelArray[pixelIndex].setColor(green)
          #END ELSE/IF
          elif(avg<0 and avg>=-25):
            pixelArray[pixelIndex].setColor(blue)
          #END ELSE/IF
          elif(avg<25 and avg>=0):
            pixelArray[pixelIndex].setColor(yellow)
          #END ELSE/IF
          elif(avg<50 and avg>=25):
            pixelArray[pixelIndex].setColor(magenta)
          #END ELSE/IF
          elif(avg>=50):
            pixelArray[pixelIndex].setColor(orange)
          #END ELSE/IF
          pixelIndex+=1
        #END FOR J
        value=value+1
        if(value<10):
          writePictureTo(picture, dir+'photo000'+str(value)+'.jpg')
        #END IF
        elif(value<100):
          writePictureTo(picture, dir+'photo00'+str(value)+'.jpg')
        #END ELSE/IF
        elif(value<1000):
          writePictureTo(picture, dir+'photo0'+str(value)+'.jpg')
        #END ELSE/IF
        else:
          writePictureTo(picture, dir+'photo'+str(value)+'.jpg')
        #END ELSE
      #END FOR I
      #END FOR K
      #Shows final picture
      show(picture)
      mov = makeMovieFromInitialFile(dir+'photo0001.jpg')
      #Functions below will make and show movie.
      mov = makeMovieFromInitialFile(dir+'photo0001.jpg')
      print mov
      writeAVI(mov, dir+'newMovie.avi', 20)
      playMovie(mov)
   #END DEF
   
   
   # DESC: This function will take in a wav file, and will separate and speed up the audio sound in three different pieces.
   #
   # INPUTS:   .wav file
   # OUTPUTS:  The playing of sped up audio sounds.
   def Aaron_Second_Project(self, event):
      #Sets directory and ability to use file from list.
      selected = self.files.getSelectedIndices()
      selectedFile = self.files.getModel( ).getElementAt( selected[0])
      selectedFile = self.currentDirectory+ "/"+ selectedFile
      #Variable declarations
      s = selectedFile
      sound = makeSound(s)
      soundValue = 0
      #Creates values for different pieces of audio files and the files the audio will be stored in.
      first = int(getLength(sound)/3)
      second = int(2*getLength(sound)/3)  
      file1 = makeEmptySound(first, 44100)
      file2 = makeEmptySound(second, 44100)
      file3 = makeEmptySound(getLength(sound), 44100)
      #For loops for placing the new audio values in the new audio files
      for sample in range(0, first):
        value = getSampleValueAt(sound, sample)
        setSampleValueAt(file1, sample, value*200)
      #END FOR
  
      for sample in range(first-1, second):
        value = getSampleValueAt(sound, sample)
        setSampleValueAt(file2, sample, value*200)
      #END FOR
  
      for sample in range(second-1, getLength(sound)):
        value = getSampleValueAt(sound, sample)
        setSampleValueAt(file3, sample, value*200)
      #END FOR
      
      #Blocking play functions will separate the play of the audio files.
      blockingPlay(file1)
      blockingPlay(file2)
      blockingPlay(file3)
   #END DEF


   # DESC: Making array of note frequencies based on piano key number (left to right, 0 to 88).
   #       The resulting frequencies are between 27.5 and 4186.01 Hz.
   #       This functions is used by Peter_First_Project()
   #
   # INPUTS:   none
   # OUTPUTS:  List, where each index is a key number, and points to the frequency
   def makeNotesArray(self):
      daNotes = {}
      for i in range(1,89):
         base = pow(2, (1.0/12))
         power = i-49
         freq = pow(base, power) * 440.0
         daNotes[i] = freq
      return daNotes
   #END DEF


   # DESC: This takes the user's chosen picture, and converts it into an audio file
   #
   # INPUTS:   picture file
   # OUTPUTS:  wav audio file
   def Peter_First_Project(self, event):
      import random
      import math
      import string   ## USED TO GET FILE NAME
      import shutil   ## USED TO COPY AND DELETE IMAGES FOLDER
      #Getting the file chosen
      selected = self.files.getSelectedIndices()
      selectedFile = self.files.getModel( ).getElementAt( selected[0])
      selectedFile = self.currentDirectory + "/"+ selectedFile
      file_name = selectedFile[selectedFile.rfind("/")+1:]
      #Checking that the file is a picture file
      fileExt = file_name.split(".")[-1]
      if ((fileExt != "jpg") and (fileExt != "JPG") and
          (fileExt != "png") and (fileExt != "PNG")):
         mywindow = swing.JFrame(size=(600,100))
         mywindow.contentPane.layout = java.awt.FlowLayout(java.awt.FlowLayout.LEFT)
         mywindow.contentPane.add(swing.JLabel(file_name+" is not a picture file"))
         mywindow.setLocationByPlatform(true)
         mywindow.visible = true
         return None
      continueThis = requestString("This function can take a while to run.\n" + 
                                    "Assume about 1 minute of processing per megabyte of the picture file.\n" + 
                                    "Continue? (y/n)")
      if continueThis != "y":
         return None
      # --------------------
      ## Importing the picture and making the note array
      picture = makePicture(selectedFile)
      totalPixels = picture.getHeight() * picture.getWidth()
      daNotes = self.makeNotesArray()
      ## Calculating the total number of samples in this song, based
      length = requestIntegerInRange("Please specify how long you want the song to be, in seconds: ", 1, 5000)
      rate = 44100 ## 44100 samples of the sound per second
      totalSamples = rate*length
      notesPerSecond = requestIntegerInRange("Please specify how many notes per second you want played,\n"+
                                              " between 2 and 16 (recommend 4 -> 10): ", 2, 16)
      sampsPerNote = int(rate/notesPerSecond)
      pixelsPerNote = int(totalPixels/(length*notesPerSecond))
      sound = makeEmptySound(totalSamples, rate)
      SAMPS = getSamples(sound)
      PIXS = getPixels(picture)
      ## This is where the sound starts (sample 0)
      lastIndex = 0
      lastPixelIndex = 0
      noteLow = requestIntegerInRange("Please give a number between 1 and 88,\n"+
                                       "which is the lowest key number\n(recommend 32)", 1, 88)
      noteHigh = requestIntegerInRange("Please give a number between "+str(noteLow)+" and 88,\n"+
                                        "which is the highest key number\n(recommend 64)", noteLow, 88)
      ## While looping through the sound by lengths of notes
      ## Last index is increased at the end of the while
      while lastIndex<(totalSamples-sampsPerNote) and lastPixelIndex<(totalPixels-pixelsPerNote):
         ## This part analyzes the pixels between the last index used in the previous
         ## iteration and that index plus the number of pixels per note.
         ## The average is calculated, and then used to get the index of the note frequency
         pixelsValueTotal = 0
         for i in range(0, pixelsPerNote):
            pixel = PIXS[lastPixelIndex + i]
            pixelsValueTotal += float(pixel.getRed()+pixel.getGreen()+pixel.getBlue())/(256*3)
         #END FOR
         lastPixelIndex += pixelsPerNote
         noteIndex = int((pixelsValueTotal/pixelsPerNote)*(noteHigh-noteLow))
         noteFreq = daNotes[noteLow+noteIndex]
         ## Splitting up the samples into sections of how
         ## many waves per note, samples per wave, and sample per
         ## quarter wave
         numWavesPerNote = int( (1.0/notesPerSecond)*noteFreq )
         sampsPerWave = sampsPerNote/numWavesPerNote
         sampsPerQWave = sampsPerWave/4
         value = float(random.randint(22000,26000)) / sampsPerQWave
         for x in range(numWavesPerNote):
            ## Offset keeps track of which wave we are at
            offset = lastIndex + (x*sampsPerWave)
            ## ModValue is what is used to create the disipating wave form
            modValue = value * (pow((0.977742), x) + 0.2242)
            for j in range(sampsPerQWave):
               SAMPS[offset + (sampsPerQWave*0) + j ].value = int(modValue * j)
            for k in range(sampsPerQWave):
               SAMPS[offset + (sampsPerQWave*1) + k ].value = int(modValue * (sampsPerQWave-k))
            for m in range(sampsPerQWave):
               SAMPS[offset + (sampsPerQWave*2) + m ].value = int(-1 * modValue * m)
            for n in range(sampsPerQWave):
               SAMPS[offset + (sampsPerQWave*3) + n ].value = int(-1 * modValue * (sampsPerQWave-n))
         #END FOR
         lastIndex += (x*sampsPerWave)
      writeSoundTo(sound, self.currentDirectory + "/" + file_name.split(".")[0] + "_sound.wav")
   #END DEF
   
   
   # DESC: This converts a given .wav file into a visualization of the waveform 
   #       (exported as a video file)
   #
   # INPUTS:   wav file
   # OUTPUTS:  avi file (and potentially a series of jpg images)
   def Peter_Second_Project(self, event):
      import random
      import string   ## USED TO GET FILE NAME
      import shutil   ## USED TO COPY AND DELETE IMAGES FOLDER
      #Getting the file chosen
      selected = self.files.getSelectedIndices()
      selectedFile = self.files.getModel( ).getElementAt( selected[0])
      selectedFile = self.currentDirectory + "/"+ selectedFile
      file_name = selectedFile[selectedFile.rfind("/")+1:]
      #Checking that the file is a wav file
      if (file_name.split(".")[-1] != "wav") and (file_name.split(".")[-1] != "WAV"):
         mywindow = swing.JFrame(size=(600,100))
         mywindow.contentPane.layout = java.awt.FlowLayout(java.awt.FlowLayout.LEFT)
         mywindow.contentPane.add(swing.JLabel(file_name+" is not a wav file"))
         mywindow.setLocationByPlatform(true)
         mywindow.visible = true
         return None
      continueThis = requestString("This function can take a while to run.\n" + 
                                    "Assume about 1.5 minutes of processing per 1 minute of audio.\n" + 
                                    "Continue? (y/n)")
      if continueThis != "y":
         return None
      # --------------------
      folder = "/visualizer_images/"
      #This creates the folder at the specified location above
      # If the folder is already created, it will first delete it, then create it again
      try:
         os.makedirs(self.currentDirectory + folder)
      except OSError:
         shutil.rmtree(self.currentDirectory + folder)
         os.makedirs(self.currentDirectory + folder)
      #Getting some basic information about the sound
      SOUND = makeSound(selectedFile)
      rate = getSamplingRate(SOUND)
      SAMPLES = getSamples(SOUND)
      numSamples = getNumSamples(SOUND)
      #Declaring necessary numbers for loops and index counters
      framesPerSec = 25
      sampleSectionsPerFrame = 40
      lastSecondSectionCount = int( sampleSectionsPerFrame*(float(5)/8) )
      nextHalfSecondSectionCount = int( sampleSectionsPerFrame*(float(3)/8) )
      #This is also how many pixels there will be per section
      # 21 Will divide nicely into the rate/framesPerSec if rate is 44100 or 22050
      pixelsPerSection = 21
      samplesPerSection = int( (rate/framesPerSec)/pixelsPerSection )
      sampleIndex = 0
      frameIndex = 0
      lastPercentage = 0
      #width and height of picture
      width = pixelsPerSection*sampleSectionsPerFrame
      height = 600
      #Finding the "loudest" sample in the given audio
      maxSampValue = 0
      for i in range(0, numSamples):
         if maxSampValue < SAMPLES[i].value:
            maxSampValue = SAMPLES[i].value
      #END FOR
      #This will be multiplied into the sample value to give
      # the vertical amount that will be added to our line
      ratio = float(height/2)/maxSampValue
      #This is an array that will hold all of the y-coordinates
      # for the section of the picture
      averagesArray = [ [0]*pixelsPerSection ]*(lastSecondSectionCount+1)
      for a in range(lastSecondSectionCount+1, sampleSectionsPerFrame):
         toBeAppended = [0]*pixelsPerSection
         for b in range(0, pixelsPerSection):
            sampleAvg = 0
            for c in range(0, samplesPerSection):
               sampleAvg += SAMPLES[sampleIndex+c].value*ratio
            sampleIndex += samplesPerSection
            toBeAppended[b] = int( (float(sampleAvg)/samplesPerSection) )
         averagesArray.append(toBeAppended)
      #This while loop will iterate through the sound, creating the appropiate image for the
      # current section of time
      while sampleIndex < ( numSamples+(samplesPerSection*(pixelsPerSection*nextHalfSecondSectionCount)) ):
         picture = makeEmptyPicture(width, height, black)
         soundColor = white
         lineColor = red
         #Adding the red line in the horizontal center of the pictures
         soundSyncLine = int((float(5)/8)*width)
         picture.addLine(lineColor, 0, (height/2), width, (height/2))
         picture.addLine(lineColor, soundSyncLine, 0, soundSyncLine, height)
         #Determining the array of averages for the 21 pixels in the new section.
         # first removes the first array (moved past it), then gets array, then appends
         averagesArray.pop(0)
         newAverages = [0]*pixelsPerSection
         for q in range(0, pixelsPerSection):
            sampleAvg = 0
            for r in range(0, samplesPerSection):
               try:
                  sampleAvg += SAMPLES[sampleIndex+r].value*ratio
               except IndexError:
                  sampleAvg += 0
            #END FOR
            sampleIndex += samplesPerSection
            newAverages[q] = int( (float(sampleAvg)/samplesPerSection) )
         #END FOR
         averagesArray.append(newAverages)
         
         #This is creating the image for this iteration
         for i in range(0, sampleSectionsPerFrame):
            for j in range(0, pixelsPerSection):
               thisX = (i*pixelsPerSection)+j
               nextX = (i*pixelsPerSection)+j+1
               try:
                  picture.addLine(soundColor, thisX, (height/2)-averagesArray[i][j], nextX, (height/2)-averagesArray[i][j+1])
               except IndexError:
                  try:
                     picture.addLine(soundColor, thisX, (height/2)-averagesArray[i][j], nextX, (height/2)-averagesArray[i+1][0])
                  except IndexError:
                     Im_Doing_Something_Here = false
            #END FOR
         #END FOR
         #Iterate frame index before saving picture
         frameIndex += 1
         #This section is for naming the picture, and padding the appropiate number of 0's
         if frameIndex<10:
            writePictureTo(picture, self.currentDirectory + folder + "frame0000" + str(frameIndex) + ".jpg")
         elif frameIndex<100:
            writePictureTo(picture, self.currentDirectory + folder + "frame000" + str(frameIndex) + ".jpg")
         elif frameIndex<1000:
            writePictureTo(picture, self.currentDirectory + folder + "frame00" + str(frameIndex) + ".jpg")  
         elif frameIndex<10000:
            writePictureTo(picture, self.currentDirectory + folder + "frame0" + str(frameIndex) + ".jpg")
         else:
            writePictureTo(picture, self.currentDirectory + folder + "frame" + str(frameIndex) + ".jpg")
      #END WHILE
      #This is where the movie is created
      mov = makeMovieFromInitialFile(self.currentDirectory + folder + "frame00001.jpg")
      writeAVI(mov, self.currentDirectory + "/" + file_name[:-4] + ".avi", framesPerSec)
      
      response = requestString("Would you like to keep the folder of images? (y/n) ")
      while (response != "y") and (response != "n"):
         response = requestString("Would you like to keep the folder of images? (y/n) ")
   
         ### MOVE IMAGES FOLDER WITH FILENAME APPENDED
      if response == 'n':
         try:
            shutil.rmtree(self.currentDirectory+folder)
         except OSError:
            deleted = false
      #END IF
      return None
   #END DEF
#END CLASS


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# MAIN
import time
printNow("Please use this GUI to run some of our previous projects")
time.sleep(1)
fcv = FileContentsViewer()
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
